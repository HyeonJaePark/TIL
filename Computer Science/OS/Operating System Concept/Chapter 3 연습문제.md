### 3.1 아래 코드에 표시된 프로그램을 사용하여 LINE A에서 출력되는 내용을 설명하라.
```c++
#include <sys/types.h>
#include <stdio.h>
#include <unistd.h>

int value = 5;

int main() {
    pid_t pid;
    
    pid = fork();

    if(pid == 0) { /* child process */
        value += 15;
        return 0;
    }
    else if (pid > 0) {/* parent process */
        wait(NULL);
        printf("PARENT: value = %d", value) /* LINE A */
        return 0;
    }
}

```
PARENT: value = 5 가 출력된다.

### 3.2 최초의 부모 프로세스를 포함하여 아래 그림에 표시된 프로그램에 의해 몇 개의 프로세스가 생성되는가?
```c++
#include <stdio.h>
#include <unistd.h>

int main() {
    /* fork a child process */
    fork();

    /* for another child process */
    fork();

    /* and fork another */
    fork();

    return 0;
}
```
8개가 생성된다.  

### 3.3 Apple 모바일 iOS 운영체제의 원래 버전은 병행 처리 기법을 제공하지 않았다. 병행 처리로 인해 운영체제에 추가되는 세 가지 주요 문제에 대해 논의하라.
1. CPU 스켸쥴러가 병행 처리 중인 프로세스를 인지하고 올바른 알고리즘을 통해서 스켸쥴링을 해야 된다.
2. 프로세스 간의 통신이 필요할 수 있고, 운영체제가 이를 위해 프로세스 간 통신 방법을 제공해야 한다.
3. 모바일 기기의 특성 상 제한된 메모리를 가지는 경우가 많기 때문에 메모리 관리를 잘못하면 프로세스 전반에 부정적 영향을 줄 수 있다. 운영체제가 제한된 메모리 공간에서 프로세스들을 잘 관리할 수 있어야 한다.  

### 3.4 일부 컴퓨터 시스템은 다수의 레지스터 집합을 제공한다. 새 문맥이 레지스터 집합 중 하나에 이미 적재된 경우 문맥 교환 시 어떤 일이 발생하는지 설명하라. 새 문맥이 레지스터 집합 아닌 메모리에 있고 모든 레지스터 집합이 사용 중이면 어떤 일이 발생하는가?
현재 CPU 레지스터 집합 포인터는 새로운 컨텍스트를 포함하는 집합을 가리키도록 변경되며, 매우 짧은 시간 안에 된다.  
컨텍스트가 메모리에 있는 경우 레지스터 세트의 컨텍스트 중 하나를 선택하여 메모리로 이동하고 새 문맥을 메모리에서 집합으로 적재해야 한다. 이 프로세스는 컨텍스트를 선택하는 방법에 따라 레지스터 세트가 하나인 시스템보다 시간이 조금 더 걸린다.  

### 3.5 프로세스가 fork() 연산을 사용하여 새로운 프로세스를 생성할 때 다음 중 어떤 상태가 부모 프로세스와 자식 프로세스 간에 공유되는가?
    1. 스택  
    2. 힙  
    3. 공유 메모리 세그먼트  
공유 메모리 세그먼트가 부모 프로세스와 자식 프로세스 간에 공유된다. 스택과 힙은 복사본이 새로 생성된 프로세스에 만들어진다.  

### 3.6 RPC 메커니즘과 관련하여 "정확히 한 번" 시맨틱을 고려하자. 네트워크 문제로 인해 클라이언트로 전송된 ACK 메시지가 손실된 경우에도 이 시맨틱을 구현한 알고리즘이 올바르게 실행되는가? 메시지 전달 순서를 설명하고 "정확히 한 번"이 여전히 보존되는지 여부를 논의하라.
"정확히 한 번"을 보장하기 위해 일반적으로 타임스탬프와 ACK 체계를 결합한다. 일반적으로 클라이언트가 타임스탬프와 함께 RPC를 서버로 보낸다. 클라이언트는 타임아웃 시계가 작동한다.  
그런 다음 클라이언트는  

    1. 원격 프로시저가 수행되었음을 알리는 ACK를 서버로부터 수신하거나  
    2. 시간 초과  

되는 두 가지 경우를 만난다.  
시간 초과되면 서버가 원격 프로시저를 수행할 수 없다고 판단하여 클라이언트는 RPC를 다시 한 번 타임스탬프와 함께 보낸다. 
클라이언트는 두 가지 이유 중 하나로 ACK를 수신하지 못할 수 있다.  

    1. 원래 RPC가 서버에서 수신되지 않거나
    2. RPC가 서버에서 올바르게 수신되고 수행되었지만 ACK가 손실되었거나  

1번 상황에서는 ACK를 사용하면 서버가 궁극적으로 RPC를 수신하고 수행할 수 있다.  
2번 상황에서는 서버가 중복 RPC를 수신하고 RPC를 두 번 수행하지 않도록 타임스탬프를 사용하여 중복으로 식별한다. 서버는 RPC가 수행되었음을 클라이언트에 알리기 위해 두 번째 ACK를 클라이언트에 다시 보내야 한다는 점에 유의해야 한다.  

### 3.7 분산 시스템이 서버 장애에 취약하다고 가정하자. RPC 실행을 위한 "정확히 한 번" 시맨틱을 보장하기 위해 어떤 기법이 필요한가?
서버가 수신된 RPC 작업, 성공적 수행 여부 및 작업 결과에 대한 정보를 담은 안정적인 저장소를 추적해야 한다. 서버 충돌이 발생하고 RPC 메시지를 수신하면 서버는 RPC가 이전에 수행되었는지 여부를 확인할 수 있으므로 RPC 실행에 대해 "정확히 한 번" 의미 체계를 보장할 수 있다.  