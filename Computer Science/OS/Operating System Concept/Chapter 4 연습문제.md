### 4.1 다중 스레딩이 단일 스레드 솔루션보다 더 나은 성능을 제공하는 세 가지 프로그래밍 예제를 제시하라.

1. 고성능 계산기
   - 병렬 처리 할 수 있는 작은 단위의 계산으로 쪼개서 더 좋은 성능의 계산기를 제공할 수 있다. 꼭 계산기가 아니더라도 병렬 처리할 수 있는 프로그램들은 다중 스레딩이 단일 스레드 솔루션보다 더 나은 성능을 제공한다.
2. 워드 프로세서
   - 그래픽을 표시하는 스레드, 사용자의 키 입력을 응답하는 스레드, 맞춤법 및 문법 검사를 수행하는 스레드 등 여러 개의 스레드가 있을 때 더 나은 성능을 제공한다. 워드 프로세서 뿐만 아니라 사용자와 상호소통하는 GUI 응용 프로그램들이 대게 그렇다.
3. 웹 서버
   - 웹 서버는 여러 개의 클라이언트들로부터 웹 페이지, 이밎, 소리 등에 대한 요청을 받는다. 단일 스레드로 작동한다면 한 번에 하나의 클라이언트만 서비스할 수 있게 되어 클라이언트들은 서비스를 받기 전까지 매우 긴 시간을 기다려야 할 것이다.

### 4.2 Amdahl의 법칙을 사용하여 (a) 2개의 처리 코어와 (b) 4개의 처리 코어에 대해 60%의 병렬 구성요소를 가진 응용 프로그램의 속도 향상 이득을 계산하라.

$speedup \leq \frac{1}{S + \frac{(1 - S)}{N}}$

a. $\frac{1}{0.4 + \frac{1 - 0.4}{2}} = 1.42$

b. $\frac{1}{0.4 + \frac{1 - 0.4}{5}} = 1.82$

### 4.3 4.1절에 설명된 다중 스레드 웹 서버는 작업 병렬 처리인가 혹은 데이터 병렬 처리인가?

데이터 병럴 처리이다. 각 스레드는 다른 데이터에 대해서 동일한 작업을 수행하고 있다.

### 4.4 사용자 수준 스레드와 커널 수준 스레드의 2가지 차이점은 무엇인가? 한 유형의 스레드가 다른 유형의 스레드보다 유리한 상황은 언제인가?

#### 사용자 수준 스레드

커널 영역의 상위에서 지원되며 일반적으로 사용자 레벨의 라이브러리를 통해 된다. 라이브러리는 스레드의 생성 및 스케쥴링 등에 관한 관리 기능을 제공한다.

##### 장점

- 스케쥴링과 동기화를 위해 시스템 콜을 하지 않기 때문에 오버헤드가 적다.
- 커널이 스레드 존재를 모르기 떄문에 유저모드와 커널모드 간 전환이 없다.
- 동일한 메모리 영역에서 스레드가 생성 및 관리되므로 속도가 빠르다.

##### 단점

- 스케쥴링 우선순위를 지원하지 않아서 어떤 스레드가 먼저 동작할지 모른다
- 하나의 스레드가 시스템 콜하면 해당 프로세스 내 모든 스레드가 중단된다

#### 커널 수준 스레드

OS에서 구현된다. 커널이 스레드의 생성 및 스케쥴링 등을 관리한다.

##### 장점

- 한 스레드가 중단되어도 같은 프로세스 내의 다른 스레드를 계속 실행할 수 있다.
- 커널이 각 스레드를 개별적으로 관리할 수 있다.

##### 단점

- 스케쥴링과 동기화를 위해 시스템 콜을 하는데 시간이 걸린다.
- 유저모드와 커널모드 간 전환이 빈번하여 성능이 저하된다.

커널 스레드는 프로세스와 연관될 필요과 없지만 모든 사용자 스레드는 프로세스에 속한다. 커널 스레드는 일반적으로 사용자 스레드보다 유지 보수 비용이 더 높고, 반드시 커널 자료구조로 구현해야 된다.

### 4.5 커널 수준 스레드 사이에서 문맥 교환을 위해 커널이 해야 할 일을 설명하라.

커널 스레드 간의 문맥 교환 시 일반적으로 스위칭되는 스레드에서 CPU 레지스터의 값을 저장하고 스케쥴링되는 새로운 스레드의 CPU 레지스터를 복원해야한다.

### 4.6 스레드가 생성될 때 어떤 자원이 사용되는가? 프로세스가 생성될 때 사용되는 자원과의 차이점은 무엇인가?

스레드가 프로세스보다 작기 때문에 일반적으로 프로세스 생성보다 스레드 생성할 때 자원을 적게 쓴다. 프로세스를 생성하려면 PCB를 할당해야 한다. PCB에는 메모리 맵, 파일 목록, 환경 변수가 포함되어 있다. 일반적으로 메모리 맵을 할당하고 관리하는 것이 가장 시간을 많이 필요로 한다. 사용자 스레드, 커널 스레드 모두 레지스터 세트, 스택, 우선순위를 유지하기 위해 작은 자료구조를 할당하는 것을 필요로 한다.

### 4.7 다대다 모델을 사용하여 운영체제가 사용자 수준 스레드를 커널에 매핑하고 매핑은 LWP를 사용한다고 가정하자. 또한 개발자는 실시간 시스템에서 사용할 실시간 스레드를 만들 수 있다고 하자. 실시간 스레드를 LWP에 바인딩해야 하는가? 여러분의 답을 설명하라.

네. 실시간 애플리케이션에는 타이밍이 중요합니다. 스레드가 실시간으로 표시되지만 LWP에 바인딩되지 않은 경우 스레드가 실행되기 전에 LWP에 연결될 때까지 기다려야 할 수 있습니다. 실시간 스레드가 실행 중(LWP에 연결됨)이고 차단(I/O를 수행해야 함, 우선 순위가 높은 실시간 스레드에 의해 미리 처리됨, 상호 제외 잠금 대기 중 등)인 상황을 고려해 보십시오. 실시간 스레드가 차단되는 동안 연결된 LWP는 다른 스레드에 할당됩니다. 실시간 스레드가 다시 실행되도록 예약된 경우 LWP에 연결될 때까지 기다려야 합니다. LWP를 실시간 스레드에 바인딩하면 스케줄이 지정된 후 스레드가 최소한의 지연으로 실행될 수 있습니다.

---

참고 문헌

<a href='https://colinch4.github.io/2020-02-02/%EC%BB%A4%EB%84%90%EB%A0%88%EB%B2%A8%EC%8A%A4%EB%A0%88%EB%93%9C-vs-%EC%9C%A0%EC%A0%80%EB%A0%88%EB%B2%A8%EC%8A%A4%EB%A0%88%EB%93%9C/'>COLIN'S BLOG</a>  
<a href='https://kspsd.tistory.com/50'>Zorba from Bit</a>
