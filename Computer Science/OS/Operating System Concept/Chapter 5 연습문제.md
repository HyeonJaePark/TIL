### 5.1 CPU 스케줄링 알고리즘은 스케줄 된 프로세스의 실행 순서를 결정한다. 하나의 프로세서에서 n개의 프로세스를 스케줄 하면 몇 개의 다른 스케줄이 가능한가?

$n!$ 만큼 가능하다.

### 5.2 선점 스케줄링과 비선점 스케줄링의 차이점을 설명하라.

선점 스케줄링은 하나의 프로세스가 끝날 때까지 CPU를 점유한다. 하지만 비선점 스케줄링은 프로세스가 완료가 되지 않아도 다른 프로세스가 CPU를 점유할 수 있다.

### 5.3 표시된 시간에 다음 프로세스가 도착한다고 가정하자. 각 프로세스는 나열된 시간 동안 실행된다. 질문에 답할 때, 비선점 스케줄링을 사용하고 결정해야 할 시점에 가지고 있는 정보를 기초로 결정을 내려야 한다.

| 프로세스 | 도착시간 | 버스트 시간 |
| :------: | :------: | :---------: |
|  $P_1$   |   0.0    |      8      |
|  $P_2$   |   0.4    |      4      |
|  $P_3$   |   1.0    |      1      |

#### a. FCFS 스케줄링 알고리즘을 사용할 경우 프로세스의 평균 총처리 시간은 얼마인가?

$\frac{8 + 11.6 + 12}{3} = 10.53$

#### b. SJF 스케줄링 알고리즘을 사용할 경우 프로세스의 평균 총처리 시간을 얼마인가?

$\frac{8 + 8 + 12.6}{3} = 9.53$

#### c. SJF 알고리즘은 성능을 향상해야 하지만 두 개의 더 짧은 프로세스가 곧 도착할 것임을 알지 못했기 때문에 시간 0에서 프로세스 $P_1$을 실행하기로 선택했다. CPU가 첫 1 단위 동안 유휴상태로 유지된 후 SJF 스케줄링이 사용되는 경우 평균 총처리 시간을 계산하라. 이 유휴시간 동안 프로세스 $P_1$ 및 $P_2$가 대기 중이므로 대기 시간이 증가할 수 있다. 이 알고리즘은 미래-지식 스케줄링으로 알려져있다.

$\frac{14 + 5.6 + 1}{3} = 6.86$

### 5.4 CPU 버스트 시간의 길이가 밀리초 단위로 다음과 같은 프로세스 집합을 고려하시오.

| 프로세스 | 버스트 시간 | 우선순위 |
| :------: | :---------: | :------: |
|  $P_1$   |      2      |    2     |
|  $P_2$   |      1      |    1     |
|  $P_3$   |      8      |    4     |
|  $P_4$   |      4      |    2     |
|  $P_5$   |      5      |    3     |

프로세스는 모두 시간 0에서 $P_1, P_2, P_3, P_4, P_5$ 순서로 도착한 것으로 가정한다.

#### a. FCFS, SJF, 비선점 우선순위(높은 우선순위가 높을수록 우선순위가 높음) 및 RR(양자 = 2)을 사용하여 이러한 프로세스의 실행을 설명하는 4개의 Grantt 차트를 그려라.

#### b. a 부분에서 각 스케줄링 알고리즘에 대한 각 프로세스의 처리 시간은 얼마인가?

#### c. 이러한 각 스케줄링 알고리즘에 대한 각 플세스의 대기 시간은 얼마인가?

#### d. 어떤 알고리즘이 최소 평균댁 시간을 보이는가(모든 프로세스에서)?

### 5.5 다음 프로세스는 선점형 라운드-로빈 스케줄링 알고리즘을 사용하여 스케줄링 된다.

| 프로세스 | 우선순위 | 버스트 | 시간 |
| :------: | :------: | :----: | :--: |
|  $P_1$   |    40    |   20   |  0   |
|  $P_2$   |    30    |   25   |  25  |
|  $P_3$   |    30    |   25   |  30  |
|  $P_4$   |    35    |   15   |  60  |
|  $P_5$   |    5     |   10   | 100  |
|  $P_6$   |    10    |   10   | 105  |

각 프로세스에는 숫자 우선순위가 할당되며 숫자가 높을수록 상대적 우선순위가 더 높다. 아래에 나열된 프로세스 외에도 시스템에는 <b>유휴 작업</b>(CPU 자원을 소비하지 않으며 P~idle~로 식별됨)이 있다. 이 작업의 우선순위는 0이며 시스템에 실행 가능한 다른 프로세스가 없을 때마다 스케줄 된다. 시간 할당량의 길이는 10단위이다. 프로세스가 우선순위가 높은 프로세스에 의해 선점되면 선점된 프로세스는 큐의 끝에 배치된다.

#### a. Gantt 차트를 사용하여 프로세스의 스케줄 순서를 보여라.

![gantt chart](../asset/Chatper%205%20Practice%20Exercises%205%20gantt%20chart.png)

#### b. 각 프로세스에 소용되는 총처리 시간은 얼마인가?

| Process | 총처리 시간 |
| :-----: | :---------: |
|  P~1~   |     20      |
|  P~2~   |     55      |
|  P~3~   |     60      |
|  P~4~   |     15      |
|  P~5~   |     20      |
|  P~6~   |     10      |

#### c. 각 프로세스의 대기 시간을 얼마인가?

| Process | 대기 시간 |
| :-----: | :-------: |
|  P~1~   |     0     |
|  P~2~   |    30     |
|  P~3~   |    35     |
|  P~4~   |     0     |
|  P~5~   |    10     |
|  P~6~   |     0     |

#### d. CPU 이용률은 얼마인가?

$\frac{105}{120} = 87.5$ %

### 5.6 다단계 큐 시스템에서 단계마다 다른 시간 할당량을 지정하는 것은 어떤 이점이 있는가?

컨텍스트 전환이 잦은 프로세스와 그렇지 않은 프로세스가 있다. 예를 들어, 대화형 프로세스의 경우 전환이 잦을 것이다. 하지만 그렇지 않은 프로세스들도 있다. 단계마다 다른 시간 할당량을 지정하면 작업 처리를 위해 더 적은 컨텍스트 스위치를 할 것이고 이는 컴퓨터 성능을 높인다.

### 5.7 많은 CPU 스케줄링 알고리즘이 매개변수화 된다. 예를 들어, RR 알고리즘에는 타임 슬라이스를 나타내는 매개변수가 필요하다. 다단계 피드백 큐에는 큐의 수, 각 큐의 스케줄링 알고리즘, 큐 간 프로세스 이주에 사용되는 기준 등을 정의하는 매개변수가 필요하다.

### 따라서 이러한 알고리즘은 실레로는 알고리즘 집합이다(예, 모든 타임 슬라이스에 대한 RR 알고리즘 집합 등). 한 알고리즘 집합은 다른 집합을 포함할 수 있다(예를 들어, FCFS 알고리즘은 무한 시간 할당량을 갖는 RR 알고리즘이다). 다음 알고리즘 집합 쌍 사이에는 어떤 관계가 있는가?

    a. 우선순위 및 SJF
    b. 다단계 피드백 큐 및 FCFS
    c. 우선순위 및 FCFS
    d. RR과 SJF

a. 가장 짧은 작업이 가장 높은 우선순위를 가진다.  
b. 가장 낮은 레벨의 MLFQ이 FCFS이다.  
c. FCFS는 가장 오래 대기하고 있는 작업에 가장 높은 우선순위를 준다.  
d. 없다.

### 5.8 CPU 스케줄링 알고리즘이 최근 과거에 가장 적은 프로세서 시간을 사용한 프로세스를 선호한다고 가정한다. 이 알고리즘이 I/O 중심 프로그램을 선호하지만 CPU 중심 프로그램을 영구적인 기아 상태로 만들지 않는 이유는 무엇인가?

I/O 중심 프로그램은 상대적으로 짧은 CPU 버스트를 요청하기 때문에 I/O 중심 프로그램을 선호하지만, I/O 중심 프로그램은 I/O를 수행하기 위해 CPU를 상대적으로 자주 포기하기 때문에 CPU 중심 프로그램을 영구적으로 기아 상태로 만들지 않는다.

### 5.9 PCS와 SCS 스케줄링을 구별하라.

사용자 수준과 커널 수준 스레드의 차이 중 하나는 그들이 어떻게 스케줄 되느냐에 있다. 다대일과 다대다 모델을 구현하는 시스템에서 스레드 라이브러리는 사용자 수준 스레드를 가용한 LWP상에서 스케줄 한다. ㅇ러한 기법은 동일한 프로세스에 속하 스레드들 사이에서 CPU를 경쟁하기 때문에 PCS로 알려져 있다. 우리가 스레드 라이브러리가 사용자 수준 스레드를 가용한 LWP상에서 스케줄 한다고 말하는 경우, 스레드가 실제로 CPU 상에서 실행 중이라는 것을 의미하지 않는다. 실제로 CPU상에서 실행되기 위해서는 운영체제가 LWP의 커널 스레드를 물리적인 CPU 코어로 스케줄 하는 것을 필요로 한다. CPU 상에 어떤 커널 스레드를 스케줄 할 거신지 결정하기 위해서 커널은 SCS를 사용한다. SCS 스케줄링에서의 CPU에 대한 경쟁은 시스템상의 모든 스레드 사이에서 일어난다.  
전형적으로, PCS는 우선순위에 따라 행해진다. 즉 스케줄러는 가장 높은 우선순위를 가진 실행 가능한 프로세스를 선택한다. 사용자 수준 스레드의 우선순위는 프로그래머에 의해 지정되고 스레드 라이브러리에 의해 조정되지 않는다. 그러나 몇몇 스레드 라이브러리는 프로그래머가 스레드의 우선순위를 변경하는 것을 허용한다. PCS는 통상 더 높은 우선순위의 스레드를 위하여 현재 실행 중인 스레드를 선점한다는 것을 주의해야 한다. 그러나 같은 우선순위의 스레드들 사이에서는 타임 슬라이스에 대한 보장은 없다.

### 5.10 전통적인 UNIX 스케줄러는 우선순위 번호와 우선순위 사이에 반비례 관계를 강제한다. 숫자가 높을수록 우선순위가 낮다. 스케줄러는 일 초마다 다음 수식을 사용하여 프로세스 우선순위를 다시 계산한다.

    Priority = (receent CPU usage / 2) + base

### 여기서 base = 60이고 recent CPU usage는 우선순위가 마지막으로 다시 계산된 이후 프로세스가 CPU를 사용한 빈도를 나타내는 값이다.

### 프로세스 P~1~의 최근 CPU 사용량이 40이고 프로세스 P~2~의 경우 18, 프로세스 P~3~의 경우 10이라고 가정한다. 우선순위를 다시 계산할 때 이 세 프로세스의 새로운 우선순위는 무엇인가? 이 정보를 기반으로 판단했을 때 전통적인 UNIX 스케줄러가 CPU 중심 프로세스의 상대적 우선순위를 올리는가 아니면 내리는가?

각각의 새로운 우선순위는 80, 69, 65이다. 전통적인 UNIX 스케줄러는 CPU 중심 프로세스의 상대적 우선순위를 내린다.
