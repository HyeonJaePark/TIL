### 6.1 6.4절에서 인터럽트를 자주 비활성화하면 시스템 클록에 영향을 줄 수 있다고 언급했다. 왜 이런 일이 발생할 수 있고 그러한 영향을 최소화할 수 있는 방법에 대해 설명하라.

시스템 클럭은 인터럽트마다 업데이트 된다. 인터럽트가 장시간 동나 비활성화 되면 시스템 클록은 정확한 시간을 잃을 수 있다.  
시스템 클럭은 스케줄링 목적으로도 사용된다. 예를 들어, 프로세스의 시간 퀀텀은 클록으로 표시 된다. 인터럽트마다 스케줄러는 현재 실행 중인 프로세스의 시간 퀀텀이 만료되었는지 여부를 판단한다. 클록 인터럽트를 사용할 수 없는 경우 스케줄러는 시간 퀀텀을 정확하게 할당 할 수 없다.  
이러한 영향은 매우 짧은 시간 동안만 인터럽트를 비활성화함으로써 최소화 할 수 있다.

### 6.2 <i><b>바쁜 대기</b></i>라는 용어의 의미는 무엇인가? 운영체제에는 어떤 다른 대기가 있는가? 바쁜 대기를 완전히 피할 수 있는가? 여러분의 답을 설명하라.

바쁜 대기란 프로세스가 프로세서를 포기하지 않고 조건이 충족되기를 기다리는 것을 의미한다.  
바쁜 대기를 피하기 위한 한 가지 방법은 대기 프로세스를 일시적으로 중지시키고 적절한 프로그램 상태에 도달하면 깨우는 것이다. 하지만 이 방법은 프로세스를 중지시키고 나중에 깨우는 것과 관련된 오버헤드를 발생시킨다.

### 6.3 스핀락이 단일 프로세서 시스템에 적합하지 않지만 다중 처리기 시스템에서는 종종 사용되는 이유를 설명하라.

스핀락이 단일 프로세스 시스템에 적합하지 않다. 왜냐하면 스핀락에서 프로세스를 분리하는 조건은 다른 프로세스를 실행해야만 얻을 수 있기 때문이다. 만약 프로세스가 프로세서를 포기하지 않는다면 다른 포르세스들은 첫 번째 프로세스가 진행되기 위해 필요한 프로그램 조건을 설정할 기회를 얻지 못한다.  
다중 처리기 시스템에서는 다른 프로세스들은 다른 프로세서에서 실행되므로 스핀락에서 첫 번째 프로세스를 실행하기 위해 프로그램 상태를 수정할 수 있다.

### 6.4 wait() 및 signal() 세마포 연산이 원자적으로 실행되지 않으면 상호 배제가 위반될 수 있음을 설명하라.

만약 값이 1일 때 두 개의 wait() 연산이 실행되고, 원자적으로 수행되지 않는다면, 두 연산은 세마포 값을 가소시켜 상호 배제를 위반할 수 있다.

### 6.5 이진 세마포를 사용하여 n개의 프로세스 간에 상호 배제를 구현하는 방법을 설명하라.

n 개의 프로세스는 세마포, 뮤택스를 공유하고 1로 초기화한다. 각각의 프로세스들은 다음과 같을 것이다.

```cpp
do {
    wait(mutex);

        /* critical section */

    signal(mutex);

        /* remainder section */
} while(true);
```

### 6.6 경쟁 조건은 많은 컴퓨터 시스템에서 가능하다. deposit(amount)와 withdraw(amount)의 두 가지 함수를 사용하여 계좌 잔고를 유지하는 은행 시스템을 고려해 보자. 이 두 함수는 은행 계좌 잔고에서 예치 또는 인출될 금액을 인자로 전달 받는다. 남편과 아내가 은행 계좌를 공유한다고 가정하자. 남편은 withdraw() 함수를 호출하고 아내는 deposit() 함수를 병행하게 호출한다. 어떻게 경쟁 조건이 발생할 수 있는지 설명하고 경쟁 조건이 발생하지 않도록 하려면 무엇을 해야 하는지 설명하라.

예를 들어, 계좌의 잔액이 $250 이라고 하자. 남편은 withdraw($50)을 수행하고 아내는 deposit($100)을 수행한다고 가정하자. 올바르게 두 함수가 작동한다면 계좌에는 잔액이 $300이 되어야 한다.  
만약 남편이 withdraw($50)을 하고 잔액 로컬 값을 $200으로 바꾸는 트랜잭션을 커밋하기 전에 아내가 deposit($100)을 수행하여 로컬 잔액 값을 $300으로 바꾸고 트랜잭션을 커밋까지 한다면 잔액 값은 $300으로 업데이트 된다. 그리고 다시 남편의 withdraw($50)으로 돌아와 트랜잭션을 커밋하면 잔액 값은 최종적으로 $200으로 업데이트가 된다. 이렇게 되면 경쟁 조건이 발생하고 잘못 된 값이 저장될 수 있다.  
이를 방지하기 위해서는 트랜잭션을 원자적으로 실행해야 된다. 남편의 withdraw() 혹은 아내의 deposit() 중 먼저 실행되는 함수가 끝나기 전까지는 다른 함수가 접근하여 값을 읽거나 변경하는 것을 막아야 한다.
