### 8.1 컴퓨터 시스템 환경과 관련이 없는 교착 상태의 예를 세 가지 나열하시오.

1. 외길에서 만난 서로 다른 방향으로 가는 두 개의 차
2. 외길에서 만난 서로 다른 방향으로 가는 두 개의 열차
3. 한 사람은 사다리를 올라가고 한 사람은 사다리를 내려갈 때

### 8.2 시스템이 불안전 상태라고 가정하자. 스레드가 교착 상태로 들어가지 않고 실행을 완료할 수 있다는 것을 보여라.

불안전 상태가 데드락을 반드시 유발하는 것은 아니다. 불안전 상태는 데드락이 발생하지 않을 것이라는 보장을 할 수 없는 상태를 말한다. 따라서 불안전 상태여도 데드락이 발생하지 않고 프로세스들을 완료할 수 있다.
예를 들어, 12개의 자원이 있고 다음 표와 같이 프로세스들이 존재한다고 하자.
||Max|Current|Need|
|:---:|:---:|:---:|:---:|
|P~0~|10|5|5|
|P~1~|4|2|2|
|P~2~|9|3|6|
현재 2개의 자원이 사용가능한 상태이다. 그리고 현재 상태는 불안전 상태이다. 프로세스 P~1~는 현재 사용 가능한 2개의 자원을 가지고 와 작업을 수행할 수 있다. 하지만 P~0~와 P~2~가 수행될 수 있다고는 장담할 수 없다.  
그러나 만약 프로세스들이 자원을 요청하지 않고 자원들을 release 한다면 가능하다. 예를 들어, P~2~가 현재 자신이 가진 자원을 release하면 사용 가능한 자원의 개수는 총 5개가 된다. 이렇게 되면 P~0~를 수행할 수 있고 이후에 P~2~도 수행할 수 있게 된다.

### 8.3 시스템의 다음 스냅숏을 고려하라.

|      | Allocation |   Max   | Available |
| :--: | :--------: | :-----: | :-------: |
|      |  A B C D   | A B C D |  A B C D  |
| T~0~ |  0 0 1 2   | 0 0 1 2 |  1 5 2 0  |
| T~1~ |  1 0 0 0   | 1 7 5 0 |           |
| T~2~ |  1 3 5 4   | 2 3 5 6 |           |
| T~3~ |  0 6 3 2   | 0 6 5 2 |           |
| T~4~ |  0 0 1 4   | 0 6 5 6 |           |

은행원 알고리즘을 사용하여 다음 질문에 답하시오.

```markdown
a. 행렬 Needs의 내용은 무엇인가?
```

Need[i][j] = Max[i][j] - Allocation[i][j]의 관계가 있다.  
따라서 아래와 같다.
||A|B|C|D|
|:---:|:---:|:---:|:---:|:---:|
|T~0~|0|0|0|0|
|T~1~|0|7|5|0|
|T~2~|1|0|0|2|
|T~3~|0|0|2|0|
|T~4~|0|6|4|2|

```markdown
b. 시스템은 안전한 상태인가?
```

시스템은 안전한 상태이다. <T~0~,T~2~,T~1~,T~3~,T~4~>의 시퀀스 순서대로 작업을 다 끝낼 수 있다.

```markdown
c. 스레드 T~1~의 요청(0,4,2,0)가 도착하면 주어진 요청은 즉시 승인될 수 있는가?
```

즉시 승인될 수 있다. 승인되고 나면 Available은 (1,1,0,0)이 되고 이 상태로 T~0~, T~2~, T~3~, T~1~, T~4~ 순서로 작업을 끝낼 수 있다.

### 8.4 교착 상태를 예방할 수 있는 가능한 방법은 다른 모든 자원보다 먼저 요청해야 하는 하나의 상위 자원을 사용하는 것이다. 예들 들어, 여러 스레드가 동기화 객체 A···E에 액세스 하려고 하면 교착 상태가 발생할 수 있다. (이러한 동기화 객체에는 mutex, 세마포, 조건 변수 등이 포함될 수 있다.) 6번째 객체 F를 추가하여 교착 상태를 예방할 수 있다. 스레드가 객체 A···E에 대한 동기화 락을 획득하려고 할 때마다 객체 F에 대한 락을 먼저 획득하여야 한다. 이 해결책은 봉쇄(containment)라고 한다. 객체 A···E에 대한 락은 객체 F에 대한 락에 포함된다. 이 기법을 8.5.4절의 순환 대기 기법과 비교하라.

본 방법은 범위가 너무 넓기 때문에 좋은 기법이 아닐 수 있다. 가능한 좁은 범위에서 락 기법을 정의하는 것이 좋다. 순환 대기 기법은 교착 상태를 피하기 위한 합리적인 접근 방식이며 락의 범위를 증가시키지 않는다.

### 8.5 8.6.3절에 제시된 안전 알고리즘이 $m * n^2$ 단위의 연산이 필요하다는 것을 증명하시오.

n = 스레드의 수, m = 자원의 종류 수

```cpp
for (int i = 0; i < n; i++) {
    for (int j = 0; i < n; j++) {
        if (!finish[i]) {
            boolean tf = true;
            for (int k = 0; k < m; k++) {
                if (need[k] > work[j][k]) {
                    tf = false;
                    break;
                }
            }
            if (tf) {
                finish[i] = true;
                for (int k = 0; k < m; k++) {
                    work[k] += allocation[j][k]
                }
            }
        }
    }
}
```

안전 알고리즘은 이중 for문으로 되어 있다. for문을 n번씩 2번 돌고 for문 내부에서 m번 돌기 때문에 $m*n^2$만큼의 연산이 필요하다.

### 8.6 한 달에 5000개의 작업을 실행하고 교착 상태 예방 또는 회피 기법이 없는 컴퓨터 시스템을 고려하자. 교착 상태는 한 달에 두 번 발생하며 운영자는 교착 상태 당 약 10개의 작업을 종료하고 다시 실행해야 한다. 각 작업의 가치는 약 2달러(CPU 시간 기준)이며 종료된 작업은 중단될 때 절반 정도 수행되는 경향이 있다.

### 시스템 프로그래머는 교착 상태 회피 알고리즘(은행원 알고리즘 같은)을 시스템에 설치하면 작업당 평균 실행 시간이 약 10% 증가하리라 추정하였다. 시스템은 현재 30%의 유휴 시간이 있기 때문에 총처리 시간이 평균 약 20% 증가하더라도 매월 5000개의 모든 작업을 여전히 실행할 수 있다.

```markdown
a. 교착 상태 방지 알고리즘 설치의 찬성의 논거는 무엇인가?
```

교착 상태 방지 알고리즘을 설치하면 교착 상태를 예방할 수 있고 교착 상태로 인한 cost를 절감할 수 있다. 현재 시스템의 30%의 유휴 시간이 있기 때문에 알고리즘을 설치한 이후에도 충분히 5000개의 작업을 실행할 수 있기 때문에 설치하는 것이 좋다.

```markdown
b. 교착 상태 방지 알고리즘 설치의 반대의 논거는 무엇인가?
```

교착 상태가 한 달의 두 번으로 그 빈도가 낮고 손실 cost도 낮기 때문에 설치할 필요가 없다.

### 8.7 시스템은 일부 스레드가 기아 상태에 있는지 감지할 수 있는가? 여러분의 대답이 "예"라면 시스템이 어떻게 할 수 있는지 설명하라. 대답이 "아니요"라면 시스템이 기아 문제를 어떻게 처리할 수 있는지 설명하라.

기아를 감지할 수 있는 방법은 타이머를 설정하는 것이다. 프로세스가 리소스를 요청하는 시간에 타이머가 시작되어서 일정 시간을 넘긴다면 기아 상태로 판단 할 수 있다.  
기아 문제를 다루는 한 가지 방법은 가장 오래 기다린 프로세스에게 할당하는 것이다.

### 8.8 다음과 같은 자원 할당 정책을 고려하자. 자원 요청 및 해제는 언제든지 허용된다. 자원이 가용하지 않아 자원 요청을 충족할 수 없는 경우 자원을 기다리며 봉쇄된 스레드를 검사한다. 봉쇄된 스레드가 필요로 하는 자원을 가지고 있으면 뺴앗아 요청 스레드에 준다. 봉쇄된 스레드가 대기 중인 자원 벡터는 빼앗긴 자원을 포함하도록 증가한다.

### 예를 들어, 시스템에서 세 가지 자원 유형이 있으며 벡터 <i>Available</i> 은 (4,2,2)로 초기화 된다. 스레드 T~0~이 (2,2,1)을 요청하면 자원을 할당받는다. T~1~이 (1,0,1)을 요청하면 역시 자원을 할당받는다. 그런 다음 T~0~이 (0,0,1)을 요청하면 봉쇄된다(자원이 가용하지 않음). T~2~가 이제 (2,0,0)을 요청하면 가용한 자원 (1,0,0)과 T~0~에 할당된 것을(T~0~이 봉쇄 상태이므로) 할당받는다. T~0~의 <i>Allocation</i> 벡터는 (1,2,1)로 내려가고 <i>Need</i> 벡터는 (1,0,1)로 올라간다.

```markdown
교착 상태가 발생할 수 있는가? 여러분의 대답이 "예"라면 예를 들어보라. "아니요"라면 어떤 필요조건이 발생할 수 없는지 명시하라.
```

데드락이 발생하지 않는다. 데드락의 네 가지 필요조건 중 하나인 비선점을 만족하지 않기 때문이다.

```markdown
무한정 봉쇄가 발생할 수 있는가? 여러분의 답을 설명하라.
```

무한정 봉쇄가 발생할 수 있다. 다른 프로세스의 선점에 의해 계속 봉쇄 될 수 있다.

### 8.9 현재 시스템의 상태가 아래와 같다.

|      | Allocation | Max     |
| :--: | :--------: | :------ |
|      |  A B C D   | A B C D |
| T~0~ |  3 0 1 4   | 5 1 1 7 |
| T~1~ |  2 2 1 0   | 3 2 1 1 |
| T~2~ |  3 1 2 1   | 3 3 2 1 |
| T~3~ |  0 5 1 0   | 4 6 1 2 |
| T~4~ |  4 2 1 2   | 6 3 2 5 |

은행원 알고리즘을 사용하여 다음 각 상태가 불안전 상태인지 결정하라. 만일 상태가 안전이라면 프로세스가 종료할 수 있는 순서를 설명하라. 그렇지 않다면 상태가 불안전한 이유를 설명하라.

```markdown
a. Available=(0,3,0,1)
```

안전 상태가 아니다. T~2~, T~1~,T~3~까지 끝낼 수 있지만 나머지 작업들은 마칠 수 없다.

```markdown
b. Available=(1,0,0,2)
```

안전 상태이다. T~1~,T~2~,T~3~,T~4~,T~0~ 순서로 작업을 끝낼 수 있다.

### 8.10 여러분이 시스템이 안전한 상태인지 여부를 결정하는 교착 상태 회피 안전 알고리즘을 코딩하였다고, 이제 교착 상태 감지 알고리즘을 구현해 달라는 요청을 받았다고 가정하자. 이미 구현된 안전 알고리즘 코드를 사용하고, $Max_i = Waiting_i + Allocation_i$ 로 다시 정의하면 교착 상태를 감지할 수 있는가? 여기서 $Waiting_i$ 는 스레드 i가 대기 중인 자원을 지정하는 벡터이며 $Allocation_i$는 8.6절에서 정의한 것과 같다. 여러분의 대답을 설명하라.

가능하다.  
$Need_i = Max_i - Allocation_i$
$Max_i = Need_i + Allocation_i$
이다.  
$Need_i$ 는 $Waiting_i$로 표현할 수 있기 때문에
$Max_i = Need_i + Allocation_i$ 으로 대체할 수 있다.

### 8.11 단일 스레드 프로세스만 관여된 교착 상태가 발생할 수 있는가? 여러분의 대답을 설명하라.

없다. Hold-and-wait에 의해 데드락이 발생할 수 없다.
