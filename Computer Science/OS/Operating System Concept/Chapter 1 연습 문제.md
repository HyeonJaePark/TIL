#### 1.1 운영체제의 세 가지 주요 목적은 무엇인가?
다양한 사용자가 컴퓨터 하드웨어에서 프로그램을 편리하고 효율적으로 실행할 수 있는 환경을 제공하기 위한 목적이 있다.  
운영체제는 컴퓨터 시스템이 동작할 때 하드웨어, 소프트웨어 및 데이터의 자원이 적절하게 사용할 수 있는 방법을 제공한다. 이들 자원을 최대한 효율적이고 공정하게 할당하는 것이 운영체제의 목적이다.  
운영체제는 오류 및 부적절한 사용을 방지하기 위해 사용자 프로그램의 실행을 감시하는 역할과 컴퓨터 시스템의 동작을 관리하고 IO 장치의 제어를 담당한다.  

#### 1.2 컴퓨팅 하드웨어를 효율적으로 사용하려면 운영체제가 필요하다고 강조하였다. 운영체제가 이 원칙을 버리고 자원을 낭비하는 것이 적절한 때는 언제인가? 그러한 시스템이 실제로 낭비하는 것이 아닌 이유는 무엇인가?
단일 사용자 시스템은 사용자를 위해 시스템 사용을 극대화해야 한다. GUI는 CPU를 낭비할 수 있지만 시스템과 사용자의 상호작용을 최적화 하기 때문에 낭비라고 보기 어려울 수 있다.

#### 1.3 실시간 환경을 위해 운영체제를 작성할 때 프로그래머가 극복해야 하는 주요 어려움은 무엇인가?
가장 큰 어려움은 운영 체제를 실시간 시스테므이 고정된 시간 제약 내에서 유지하는 것이다. 만약 시스템이 작업을 일정 시간 내에 완수하지 못하면, 이는 전체 시스템에 영향을 줄 수 있다. 따라서 실시간 환경을 위해 운영체제를 작성할 때 프로그래머는 스켸쥴링 계획이 시간 제약을 초과해서 응답하지 않도록 하는 것이 중요하다.

#### 1.4 운영체제의 다양한 정의를 염두에 두고 운영체제에 웹 브라우저 및 메일 프로그램과 같은 응용 프로그램이 포함되어야 하는지 생각해 보라. 포함시킨다와 포함시키지 않는다는 주장 모두의 입장에서 논증하라.
찬성하는 입장은 만약 응용 프로그램이 운영 체제에 포함되면, 커널 내에서 프로그램을 동작시켜 커널 밖에서 실행시키는 것보다 성능적으로 우위를 가질 수 있다.  
그러나 일반적으로 응용 프로그램을 운영 체제에 내장하는 것을 반대하는 주장이 지배적이다.
1. 응용 프로그램은 운영 체제의 일부가 아니며
2. 커널 내에서 실행함으로써 얻는 성능상의 이점보다 보안 취약성 문제가 더 심각하며
3. 운영 체제의 비대화를 초대한다. 

#### 1.5 커널 모드와 사용자 모드의 구별은 기본적인 형태의 보호(보안)으로서 어떤 기능을 하는가?
특정 명령은 CPU가 커널 모드에 있을 때만 가능하다. 하드웨어 장치들은 프로그램이 커널 모드에 있을 때만 접근할 수 있고, 인터럽트는 CPU가 커널 모드에 있을 때에만 (비)활성화 할 수 있다. 따라서 사용자 모드에서 실행할 때 CPU의 기능이 매우 제한되므로 중요한 리소스의 보호를 강제할 수 있다.

#### 1.6 다음 중 특권 명령이어야 하는 명령어는 무엇인가?  
>> a. 타이머 설정
>> b. 클록 읽기
>> c. 메모리 내용 삭제
>> d. 트랩 명령의 실행
>> e. 인터럽트 끄기
>> f. 장치 상태 테이블의 항목 수정
>> g. 사용자에서 커널모드로 전환
>> h. I/O 장치 액세스

a, c, e, f, h 가 특권 명령이어야 하는 명령어이다. 

#### 1.7 일부 초기 컴퓨터는 운영체제를 사용자 작업이나 운영체제 자체에서 수정할 수 없는 메모리 파티션에 배치하여 운영체제를 보호하였다. 이러한 기법에서 발생할 수 있다고 생각되는 두 가지 어려움을 설명하라.
운영체제에 필요한 데이터가 보호되지 않는 메모리에 저장되고, 이에 따라 권한이 없는 사용자가 데이터에 접근할 수 있게 된다.
또한 운영체제 자체에서 수정할 수 없는 메모리 파티션에 배치되기 때문에 운영체제를 유지보수 하기 어려운 문제가 있다.

#### 1.8 일부 CPU는 세 개 이상의 작동 모드를 제공한다. 이 다중 모드를 사용할 수 있는 두 가지 경우는 무엇인가?
여러 모드를 사용하면 세분화된 보안 정책을 제공할 수 있다. 또 다른 경우는 커널 코드 내에서 다른 구분을 제공한다.

#### 1.9 타이머는 현재 시간을 계산하는 데 사용될 수 있다. 어떻게 계산이 가능한지 간단하게 설명하라.
타이머는 지정된 시간 후 컴퓨터를 인터럽트 하도록 설정할 수 있다. 인터럽트에 의해 깨워지면, 지금까지 수신한 인터럽트의 수를 추적하기 위해 사용하는 로컬 상태를 업데이트 할 수 있다. 

#### 1.10 캐시가 유용한 두 가지 이유를 제시하라. 어떤 문제를 해결할 수 있는가? 어떤 문제를 야기하는가? 캐시의 크기를 캐싱하는 장치만큼 크게 만들 수 있다면(예: 디스크의 크기와 같은 캐시) 캐시의 용량을 늘린 후 원래 장치를 제거하지 않는 이유는 무엇인가?
저장장치 시스템은 다양한 속도와 용량을 가진다. 속도와 용량은 트레이드 오프 관계로 속도가 빠르면 용량은 작고, 속도가 느리면 용량이 큰 경향이 있다. 따라서 장치간의 통신 속도 차이가 발생하고 이는 병목현상을 야기하고 이는 곧 시스템 성능 하락으로 이어진다. 캐시를 통해서 병목현상을 해결할 수 있다. 캐시는 통신 속도가 빠르기 때문에 캐시에 데이터를 저장하면 병목현상을 방지할 수 있다.  
캐시의 데이터는 구성 요소의 데이터와 일관성을 유지해야 한다. 구성 요소에 데이터 값 변경이 있고 캐시에도 데이터가 있는 경우 캐시도 업데이트 해야 한다. 만약 캐시의 데이터가 업데이트 되지 않으면 의도하지 않은 동작을 실행할 수도 있다. 하나 이상의 프로세스가 데이터에 액세스할 수 있는 다중 프로세서 시스템에서 특히 문제가 된다.
캐시의 용량을 늘린 후 원래 장치를 제거하지 않는 이유는 캐시는 고속처리를 위해 고속처리 장치 근처의 한정된 공간을 사용할 수 있기에 대체로 매우 작은 작은 공간만을 활용할 수 있으며 이로 인해 기억가능한 용량이 작기에 대용량 캐시를 구현하는 것은 현실적으로 어렵다. 또한 작은 공간에 대용량 캐시를 만드는 것은 비용이 매우 비싸기 때문에 현재의 캐시 설계가 주력으로 활용된다.

#### 1.11 분산 시스템의 클라이언트-서버 시스템과 피어 간 모델의 차이를 설명하라.
클라이언트-서버 모델은 클라이언트와 서버의 역할을 확실히 구분한다. 클라이언트가 서버에게 제공되는 서비스를 요청하는 방식이다. 하지만 피어 간 모델에서는 이러한 구분이 모호하다. 피어간 모델에서는 모든 피어가 클라이언트이자 동시에 서버 역할을 둘 다 수행한다. 노드는 다른 피어로부터 서비스를 요청하기도 하고 다른 피어에게 서비스를 제공하기도 한다.


---
참고문헌
Abraham Silberschatz, Peter Baer Galvin, Greg Gagne-<i>Operating System Concept 10th Edition
[<a href='https://engineeringcode.tistory.com/138'>공학코드 연구노트</a>]